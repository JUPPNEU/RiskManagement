const commandLineArgs = require('command-line-args');
const path = require('path');
const process = require('process');
const execSync = require('child_process').execSync;
const logger = require('../logger');
const { DEPLOY_TARGET_CF, DEPLOY_TARGET_MS, WEB_FACTORY_NAME } = require('../utils');
const fs = require('fs');

const optionDefinitions = [
  { name: 'target', type: String, multiple: false },
  { name: 'name', type: String, multiple: false },
  { name: 'project', type: String, multiple: false },
  { name: 'dist', type: String, multiple: false },
  { name: 'showqr', type: Boolean, multiple: false },
  { name: 'force', type: Boolean, multiple: false },
  { name: 'preview', type: Boolean, multiple: false },
  { name: 'create', type: Boolean, multiple: false },
  { name: 'lcap', type: Boolean, multiple: false },
  { name: 'destination', type: String, multiple: false },
  { name: 'destinationUrl', type: String, multiple: false },
  { name: 'uaa', type: String, multiple: false },
  { name: 'marker', type: String, multiple: false },
  { name: 'zip', type: String, multiple: false },
  { name: 'neo', type: Boolean, multiple: false },
  { name: 'adminApi', type: String, multiple: false },
  { name: 'user', type: String, multiple: false },
  { name: 'pwd', type: String, multiple: false },
  { name: 'fetch', type: String, multiple: false },
  { name: 'csrfToken', type: String, multiple: false },
  { name: 'cookie', type: String, multiple: false },
  { name: 'externals', type: String, multiple: true },
  { name: 'filters', type: String, multiple: true },
  { name: 'ts-target', type: String, multiple: false },
  { name: 'wmf', type: Boolean, multiple: false },
  { name: 'runtime', type: String, multiple: false }
];

let options = commandLineArgs(optionDefinitions);
let cfToken = "";
function getProjectFolder() {
  if (options['project']) {
    let fullPath = path.resolve(options['project']);
    if (fs.existsSync(fullPath)) {
      return fullPath;
    } else {
      console.error(`failed to find path ${fullPath}`);
      process.exit(-1);
    }
  } else {
    let sCurrentPath = process.cwd();
    return sCurrentPath;
  }
}

function getCFToken() {
  try {
    let oauthToken = execSync('cf oauth-token');
    if (oauthToken) {
      return oauthToken.toString().trim();
    } else {
      return "";
    }
  } catch (error) {
    return "";
  }
}
function processArguments() {
  function getMissingRequiredArgumentMessage() {
    if (!options['target']) {
      return logger.getError('Missing target option');
    }
    if ((options['target'] !== DEPLOY_TARGET_CF) && (options['target'] !== DEPLOY_TARGET_MS)) {
      return logger.getError(`Target should be module ${DEPLOY_TARGET_CF} or ${DEPLOY_TARGET_MS}`);
    }

    return null;
  }

  if (options['target'] === DEPLOY_TARGET_MS && options['neo']) {
    //
  } else {
    cfToken = getCFToken();
    if (!cfToken) {
      console.error(logger.getError("No cloud foundry token, please login cf to continue"));
      process.exit(-1);
    }
  }

  const missingArgumentMessage = getMissingRequiredArgumentMessage();
  if (missingArgumentMessage) {
    console.error(missingArgumentMessage);
  }
  if (missingArgumentMessage) {//|| options.help
    const getUsage = require('command-line-usage')

    const sections = [
      {
        header: 'Build MDK to Web Application',
        content: 'Build MDK metadata project to a Web module or MTA application with Web Module.'
      },
      {
        header: 'Options',
        optionList: [
          {
            name: 'target',
            typeLabel: '',
            description: 'Type of the build result, it can be module or mta'
          },
          {
            name: 'name',
            typeLabel: '',
            description: 'the app name'
          },
          {
            name: 'project',
            typeLabel: '[underline]{folder}',
            description: 'The location of the mdk application definitions.'
          },
          {
            name: 'dist',
            typeLabel: '[underline]{folder}',
            description: 'The location of the build result.'
          },
          {
            name: 'showqr',
            typeLabel: '',
            description: 'if it is true, then show qrcode for onboarding'
          },
          {
            name: 'force',
            typeLabel: '',
            description: 'if it is true, then update whole mta'
          },
          {
            name: 'preview',
            typeLabel: '',
            description: 'It uses mobile services preview or web preview runtime'
          },
          {
            name: 'lcap',
            typeLabel: '',
            description: 'if it is true, then read lcap config from .project.json'
          },
          {
            name: 'marker',
            typeLabel: '',
            description: 'the marker in output log'
          },
          {
            name: 'create',
            typeLabel: '',
            description: 'if it is true, then create mobile app'
          },
          {
            name: 'destination',
            typeLabel: '',
            description: 'the destination name needs to be created'
          },
          {
            name: 'destinationUrl',
            typeLabel: '',
            description: 'the destination URL needs to be created'
          },
          {
            name: 'uaa',
            typeLabel: '',
            description: 'the uaa for the mobile app'
          },
          {
            name: 'zip',
            typeLabel: '',
            description: 'the upload bundle zip file'
          },
          {
            name: 'fetch',
            typeLabel: '',
            description: 'get token,application,destination or xml from mobile'
          },
          {
            name: 'csrfToken',
            typeLabel: '',
            description: 'the csrf token for neo mobile services'
          },
          {
            name: 'cookie',
            typeLabel: '',
            description: 'the cookie for neo mobile services'
          },
          {
            name: 'externals',
            typeLabel: '[underline]{module-name module-name ...}',
            description: 'Space-delimited list of NPM modules to be excluded from the bundle. Use this option for dependencies you expect to be in the environment when the application is built.  '
          },
          {
            name: 'filters',
            typeLabel: '[underline]{module-name module-name ...}',
            description: 'Space-delimited list of files excluded from the bundle.'
          },
          {
            name: 'ts-target',
            typeLabel: '',
            description: 'typescript loader for es5 or es6'
          },
          {
            name: 'wmf',
            description: 'If this option is specified, the script will use Webpack Module Federation to generate the bundle.'
          },
          {
            name: 'runtime',
            typeLabel: '',
            description: 'production, preview or development url'
          }
        ]
      }
    ]
    const usage = getUsage(sections);
    console.log(usage);
    process.exit(-1);
  }
}


exports.target = function () {
  return options['target'];
}

exports.name = function () {
  if (options['name']) {
    return options['name'];//.replace(/\./g, '');
  }
  return "";
}

exports.project = function () {
  return getProjectFolder();
}

exports.cfToken = function () {
  return cfToken;
}

exports.force = function () {
  return !!options['force'];
}

exports.showqr = function () {
  return !!options['showqr'];
}

exports.preview = function () {
  return !!options['preview'];
}

exports.dist = function () {
  let sProjectFolder = getProjectFolder();
  if (options['dist']) {
    return path.resolve(options['dist']);
  } else {
    return path.resolve(path.join(sProjectFolder, "..", WEB_FACTORY_NAME));
  }
}

exports.lcap = function () {
  return !!options['lcap'];
}

exports.marker = function () {
  return options['marker'] ? options['marker'] : "";
}

exports.create = function () {
  return !!options['create'];
}

exports.destination = function () {
  if (options['destination']) {
    return options['destination'];
  }
  return "";
}

exports.destinationUrl = function () {
  if (options['destinationUrl']) {
    return options['destinationUrl'];
  }
  return "";
}

exports.uaa = function () {
  if (options['uaa']) {
    return options['uaa'];
  }
  return "";
}

exports.zip = function () {
  if (options['zip']) {
    return path.resolve(options['zip']);
  }
  return "";
}

exports.neo = function () {
  return !!options['neo'];
}

exports.adminApi = function () {
  if (options['adminApi']) {
    if (!options['adminApi'].endsWith("/")) {
      return `${options['adminApi']}/`;
    } else {
      return options['adminApi'];
    }
  }
  return "";
}
exports.user = function () {
  if (options['user']) {
    return options['user'];
  }
  return "";
}
exports.pwd = function () {
  if (options['pwd']) {
    return options['pwd'];
  }
  return "";
}

exports.fetch = function () {
  if (options['fetch']) {
    return options['fetch'];
  }
  return "";
}

exports.csrfToken = function () {
  if (options['csrfToken']) {
    return options['csrfToken'];
  }
  return "";
}

exports.cookie = function () {
  if (options['cookie']) {
    return JSON.parse(options['cookie']);
  }
  return "";
}

exports.externals = function () {
  return options['externals'];
}

exports.filters = function () {
  return options['filters'] || [];
}

exports.tsTarget = function () {
  return options['ts-target'];
}

exports.useWmf = function () {
  return !!options['wmf'];
}


exports.runtime = function () {
  return options['runtime']||"";
}

processArguments();
